Perfect â€” letâ€™s make your **Troubleshooting** section fully comprehensive by also covering **async pitfalls** along with DB, Auth, Agent, Import, and Docker issues.

---

## Troubleshooting

### **Database (DB) Errors**

* **Connection parameters**: Verify `DB_HOST`, `DB_PORT`, `DB_NAME`, `DB_USER`, and `DB_PASSWORD` in `.env`.
* **Network/firewall**: Ensure DB host is reachable (`ping`, `psql`).
* **Permissions**: Confirm DB user has correct privileges.
* **Migrations**: Run DB migrations if schema/tables are missing.
* **SSL/Encryption**: Add SSL parameters if required by the DB provider.

---

### **Authentication (Auth) Errors**

* **Bearer token format**:

  ```
  Authorization: Bearer <token>
  ```
* **Expiry**: Refresh or regenerate tokens if expired.
* **Scopes/audience**: Ensure token has correct claims.
* **Env mismatch**: Double-check UAT/DEV/PROD configs.
* **Debugging**: Decode JWT with tools like `jwt.io` to inspect claims.

---

### **Agent Errors**

* **API Key**: Confirm `AZURE_OPENAI_API_KEY` / `OPENAI_API_KEY` is set.
* **Deployment names**: Validate `AZURE_OPENAI_TEXT_DEPLOYMENT_NAME` and embeddings deployment.
* **Logs**: Inspect agent logs for timeouts, invalid payloads, or rate limits.
* **Quota**: Check subscription quota and rate-limiting dashboards.
* **Retries**: Implement exponential backoff for transient failures.

---

### **Import Errors**

* **PYTHONPATH**: Ensure `src/` is added:

  ```bash
  export PYTHONPATH=./src:$PYTHONPATH
  ```
* **Relative imports**: Use explicit relative imports inside packages.
* **Virtual environment**: Run in correct venv with all dependencies installed.
* **Dependencies**:

  ```bash
  pip install -r requirements.txt
  ```
* **Circular imports**: Refactor code structure to break cycles.

---

### **Docker Issues**

* **Environment variables**: Confirm `.env` values are passed to containers.
* **Build caching**: If changes donâ€™t reflect:

  ```bash
  docker-compose build --no-cache
  ```
* **Networking**: Use service names (`db:5432`) instead of `localhost`.
* **Volume mounts**: Ensure local source code is mounted properly.
* **Logs**: View logs with:

  ```bash
  docker-compose logs <service>
  ```
* **Health checks**: Define proper `healthcheck` in compose/K8s manifests.
* **Permissions**: Watch for UID/GID mismatches between host and container.
* **Image optimization**: Use multi-stage builds and slim base images.

---

### **Async Pitfalls**

* **Blocking code in async functions**: Avoid using `time.sleep()`, `requests`, or blocking DB drivers inside `async def`. Use `asyncio.sleep()`, `httpx`, or async DB clients (`asyncpg`).
* **Unawaited coroutines**: Always `await` coroutines; otherwise, they wonâ€™t execute as expected.
* **Event loop conflicts**: Running multiple loops (e.g., `asyncio.run()` inside FastAPI/Uvicorn) can cause crashes. Use `await` within the running loop instead.
* **Concurrent DB access**: Use connection pools with async drivers to avoid race conditions.
* **Error handling**: Wrap coroutines in `try/except` to prevent silent failures.
* **Task leaks**: Ensure background tasks created with `asyncio.create_task()` are properly awaited or cancelled on shutdown.
* **Resource cleanup**: Close DB connections, sessions, and files with async context managers (`async with`).
* **Debugging async code**: Enable debug mode for asyncio:

  ```python
  import asyncio
  asyncio.get_event_loop().set_debug(True)
  ```

---

ðŸ‘‰ Do you want me to **add example code snippets** for these async pitfalls (like bad vs good patterns) so the troubleshooting guide is more actionable?
